{"/home/travis/build/npmtest/node-npmtest-inferno/test.js":"/* istanbul instrument in package npmtest_inferno */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-inferno/lib.npmtest_inferno.js":"/* istanbul instrument in package npmtest_inferno */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_inferno = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_inferno = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-inferno/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-inferno && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_inferno */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_inferno\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_inferno.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_inferno.rollup.js'] =\n            local.assetsDict['/assets.npmtest_inferno.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_inferno.__dirname +\n                    '/lib.npmtest_inferno.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/index.js":"module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/index.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nexports.NO_OP = inferno_shared_1.NO_OP;\nvar normalization_1 = require(\"./core/normalization\");\nexports.getFlagsForElementVnode = normalization_1.getFlagsForElementVnode;\nexports.internal_normalize = normalization_1.normalize;\nvar options_1 = require(\"./core/options\");\nexports.options = options_1.options;\nvar VNodes_1 = require(\"./core/VNodes\");\nexports.cloneVNode = VNodes_1.cloneVNode;\nexports.createVNode = VNodes_1.createVNode;\nvar constants_1 = require(\"./DOM/constants\");\nexports.internal_isUnitlessNumber = constants_1.isUnitlessNumber;\nvar linkEvent_1 = require(\"./DOM/events/linkEvent\");\nexports.linkEvent = linkEvent_1.linkEvent;\nvar patching_1 = require(\"./DOM/patching\");\nexports.internal_patch = patching_1.patch;\nvar rendering_1 = require(\"./DOM/rendering\");\nexports.internal_DOMNodeMap = rendering_1.componentToDOMNodeMap;\nexports.createRenderer = rendering_1.createRenderer;\nexports.findDOMNode = rendering_1.findDOMNode;\nexports.render = rendering_1.render;\nvar utils_1 = require(\"./DOM/utils\");\nexports.EMPTY_OBJ = utils_1.EMPTY_OBJ;\nif (process.env.NODE_ENV !== 'production') {\n    /* tslint:disable-next-line:no-empty */\n    var testFunc = function testFn() { };\n    if ((testFunc.name || testFunc.toString()).indexOf('testFn') === -1) {\n        inferno_shared_1.warning(('It looks like you\\'re using a minified copy of the development build ' +\n            'of Inferno. When deploying Inferno apps to production, make sure to use ' +\n            'the production build which skips development warnings and is faster. ' +\n            'See http://infernojs.org for more details.'));\n    }\n}\nvar version = '3.0.4';\nexports.version = version;\n// we duplicate it so it plays nicely with different module loading systems\nexports.default = {\n    getFlagsForElementVnode: normalization_1.getFlagsForElementVnode,\n    linkEvent: linkEvent_1.linkEvent,\n    // core shapes\n    createVNode: VNodes_1.createVNode,\n    // cloning\n    cloneVNode: VNodes_1.cloneVNode,\n    // used to shared common items between Inferno libs\n    NO_OP: inferno_shared_1.NO_OP,\n    EMPTY_OBJ: utils_1.EMPTY_OBJ,\n    // DOM\n    render: rendering_1.render,\n    findDOMNode: rendering_1.findDOMNode,\n    createRenderer: rendering_1.createRenderer,\n    options: options_1.options,\n    version: version,\n    internal_patch: patching_1.patch,\n    internal_DOMNodeMap: rendering_1.componentToDOMNodeMap,\n    internal_isUnitlessNumber: constants_1.isUnitlessNumber,\n    internal_normalize: normalization_1.normalize\n};\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno-shared/index.js":"module.exports = require('./dist');\nmodule.exports.default = module.exports;\n\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno-shared/dist/index.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NO_OP = '$NO_OP';\r\nexports.ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\r\n// This should be boolean and not reference to window.document\r\nexports.isBrowser = !!(typeof window !== 'undefined' && window.document);\r\nfunction toArray(children) {\r\n    return exports.isArray(children) ? children : (children ? [children] : children);\r\n}\r\nexports.toArray = toArray;\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nexports.isArray = Array.isArray;\r\nfunction isStatefulComponent(o) {\r\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\r\n}\r\nexports.isStatefulComponent = isStatefulComponent;\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === 'string' || type === 'number';\r\n}\r\nexports.isStringOrNumber = isStringOrNumber;\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nexports.isNullOrUndef = isNullOrUndef;\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nexports.isInvalid = isInvalid;\r\nfunction isFunction(o) {\r\n    return typeof o === 'function';\r\n}\r\nexports.isFunction = isFunction;\r\nfunction isString(o) {\r\n    return typeof o === 'string';\r\n}\r\nexports.isString = isString;\r\nfunction isNumber(o) {\r\n    return typeof o === 'number';\r\n}\r\nexports.isNumber = isNumber;\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nexports.isNull = isNull;\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nexports.isTrue = isTrue;\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nexports.isUndefined = isUndefined;\r\nfunction isObject(o) {\r\n    return typeof o === 'object';\r\n}\r\nexports.isObject = isObject;\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = exports.ERROR_MSG;\r\n    }\r\n    throw new Error(\"Inferno Error: \" + message);\r\n}\r\nexports.throwError = throwError;\r\nfunction warning(message) {\r\n    console.warn(message);\r\n}\r\nexports.warning = warning;\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key in second) {\r\n            out[key] = second[key];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nexports.combineFrom = combineFrom;\r\nfunction Lifecycle() {\r\n    this.listeners = [];\r\n}\r\nexports.Lifecycle = Lifecycle;\r\nLifecycle.prototype.addListener = function addListener(callback) {\r\n    this.listeners.push(callback);\r\n};\r\nLifecycle.prototype.trigger = function trigger() {\r\n    var listeners = this.listeners;\r\n    var listener;\r\n    // We need to remove current listener from array when calling it, because more listeners might be added\r\n    while (listener = listeners.shift()) {\r\n        listener();\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/core/normalization.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar VNodes_1 = require(\"./VNodes\");\nfunction applyKey(key, vNode) {\n    vNode.key = key;\n    return vNode;\n}\nfunction applyKeyIfMissing(key, vNode) {\n    if (inferno_shared_1.isNumber(key)) {\n        key = \".\" + key;\n    }\n    if (inferno_shared_1.isNull(vNode.key) || vNode.key[0] === '.') {\n        return applyKey(key, vNode);\n    }\n    return vNode;\n}\nfunction applyKeyPrefix(key, vNode) {\n    vNode.key = key + vNode.key;\n    return vNode;\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        var key = currentKey + \".\" + index;\n        if (!inferno_shared_1.isInvalid(n)) {\n            if (inferno_shared_1.isArray(n)) {\n                _normalizeVNodes(n, result, 0, key);\n            }\n            else {\n                if (inferno_shared_1.isStringOrNumber(n)) {\n                    n = VNodes_1.createTextVNode(n, null);\n                }\n                else if (VNodes_1.isVNode(n) && n.dom || (n.key && n.key[0] === '.')) {\n                    n = VNodes_1.directClone(n);\n                }\n                if (inferno_shared_1.isNull(n.key) || n.key[0] === '.') {\n                    n = applyKey(key, n);\n                }\n                else {\n                    n = applyKeyPrefix(currentKey, n);\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction normalizeVNodes(nodes) {\n    var newNodes;\n    // we assign $ which basically means we've flagged this array for future note\n    // if it comes back again, we need to clone it, as people are using it\n    // in an immutable way\n    // tslint:disable\n    if (nodes['$']) {\n        nodes = nodes.slice();\n    }\n    else {\n        nodes['$'] = true;\n    }\n    // tslint:enable\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var n = nodes[i];\n        if (inferno_shared_1.isInvalid(n) || inferno_shared_1.isArray(n)) {\n            var result = (newNodes || nodes).slice(0, i);\n            _normalizeVNodes(nodes, result, i, \"\");\n            return result;\n        }\n        else if (inferno_shared_1.isStringOrNumber(n)) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, VNodes_1.createTextVNode(n, null)));\n        }\n        else if ((VNodes_1.isVNode(n) && n.dom !== null) || (inferno_shared_1.isNull(n.key) && !(n.flags & 64 /* HasNonKeyedChildren */))) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, VNodes_1.directClone(n)));\n        }\n        else if (newNodes) {\n            newNodes.push(applyKeyIfMissing(i, VNodes_1.directClone(n)));\n        }\n    }\n    return newNodes || nodes;\n}\nexports.normalizeVNodes = normalizeVNodes;\nfunction normalizeChildren(children) {\n    if (inferno_shared_1.isArray(children)) {\n        return normalizeVNodes(children);\n    }\n    else if (VNodes_1.isVNode(children) && children.dom !== null) {\n        return VNodes_1.directClone(children);\n    }\n    return children;\n}\nfunction normalizeProps(vNode, props, children) {\n    if (vNode.flags & 3970 /* Element */) {\n        if (inferno_shared_1.isNullOrUndef(children) && !inferno_shared_1.isNullOrUndef(props.children)) {\n            vNode.children = props.children;\n        }\n        if (!inferno_shared_1.isNullOrUndef(props.className)) {\n            vNode.className = props.className;\n            delete props.className;\n        }\n    }\n    if (props.ref) {\n        vNode.ref = props.ref;\n        delete props.ref;\n    }\n    if (!inferno_shared_1.isNullOrUndef(props.key)) {\n        vNode.key = props.key;\n        delete props.key;\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    if (type === 'svg') {\n        return 128 /* SvgElement */;\n    }\n    else if (type === 'input') {\n        return 512 /* InputElement */;\n    }\n    else if (type === 'select') {\n        return 2048 /* SelectElement */;\n    }\n    else if (type === 'textarea') {\n        return 1024 /* TextareaElement */;\n    }\n    else if (type === 'media') {\n        return 256 /* MediaElement */;\n    }\n    return 2 /* HtmlElement */;\n}\nexports.getFlagsForElementVnode = getFlagsForElementVnode;\nfunction normalize(vNode) {\n    var props = vNode.props;\n    var children = vNode.children;\n    // convert a wrongly created type back to element\n    // Primitive node doesn't have defaultProps, only Component\n    if (vNode.flags & 28 /* Component */) {\n        // set default props\n        var type = vNode.type;\n        var defaultProps = type.defaultProps;\n        if (!inferno_shared_1.isNullOrUndef(defaultProps)) {\n            if (!props) {\n                props = vNode.props = defaultProps; // Create new object if only defaultProps given\n            }\n            else {\n                for (var prop in defaultProps) {\n                    if (inferno_shared_1.isUndefined(props[prop])) {\n                        props[prop] = defaultProps[prop];\n                    }\n                }\n            }\n        }\n        if (inferno_shared_1.isString(type)) {\n            vNode.flags = getFlagsForElementVnode(type);\n            if (props && props.children) {\n                vNode.children = props.children;\n                children = props.children;\n            }\n        }\n    }\n    if (props) {\n        normalizeProps(vNode, props, children);\n        if (!inferno_shared_1.isInvalid(props.children)) {\n            props.children = normalizeChildren(props.children);\n        }\n    }\n    if (!inferno_shared_1.isInvalid(children)) {\n        vNode.children = normalizeChildren(children);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        // This code will be stripped out from production CODE\n        // It helps users to track errors in their applications.\n        var verifyKeys = function (vNodes) {\n            var keyValues = vNodes.map(function (vnode) {\n                return vnode.key;\n            });\n            keyValues.some(function (item, idx) {\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\n                if (hasDuplicate) {\n                    inferno_shared_1.warning('Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:' + item);\n                }\n                return hasDuplicate;\n            });\n        };\n        if (vNode.children && Array.isArray(vNode.children)) {\n            verifyKeys(vNode.children);\n        }\n    }\n}\nexports.normalize = normalize;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/core/VNodes.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar utils_1 = require(\"../DOM/utils\");\nvar normalization_1 = require(\"./normalization\");\nvar options_1 = require(\"./options\");\nfunction VNode(children, className, flags, key, props, ref, type) {\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key;\n    this.props = props;\n    this.ref = ref;\n    this.type = type;\n}\n/**\n * Creates virtual node\n * @param {number} flags\n * @param {string|Function|null} type\n * @param {string|null=} className\n * @param {object=} children\n * @param {object=} props\n * @param {*=} key\n * @param {object|Function=} ref\n * @param {boolean=} noNormalise\n * @returns {VNode} returns new virtual node\n */\nfunction createVNode(flags, type, className, children, props, key, ref, noNormalise) {\n    if (flags & 16 /* ComponentUnknown */) {\n        flags = inferno_shared_1.isStatefulComponent(type) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n    }\n    var vNode = new VNode(children === void 0 ? null : children, className === void 0 ? null : className, flags, key === void 0 ? null : key, props === void 0 ? null : props, ref === void 0 ? null : ref, type);\n    if (noNormalise !== true) {\n        normalization_1.normalize(vNode);\n    }\n    if (options_1.options.createVNode !== null) {\n        options_1.options.createVNode(vNode);\n    }\n    return vNode;\n}\nexports.createVNode = createVNode;\nfunction directClone(vNodeToClone) {\n    var newVNode;\n    var flags = vNodeToClone.flags;\n    if (flags & 28 /* Component */) {\n        var props = void 0;\n        var propsToClone = vNodeToClone.props;\n        if (!propsToClone) {\n            props = utils_1.EMPTY_OBJ;\n        }\n        else {\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, null, props, vNodeToClone.key, vNodeToClone.ref, true);\n        var newProps = newVNode.props;\n        if (newProps) {\n            var newChildren = newProps.children;\n            // we need to also clone component children that are in props\n            // as the children may also have been hoisted\n            if (newChildren) {\n                if (inferno_shared_1.isArray(newChildren)) {\n                    var len = newChildren.length;\n                    if (len > 0) {\n                        var tmpArray = [];\n                        for (var i = 0; i < len; i++) {\n                            var child = newChildren[i];\n                            if (inferno_shared_1.isStringOrNumber(child)) {\n                                tmpArray.push(child);\n                            }\n                            else if (!inferno_shared_1.isInvalid(child) && isVNode(child)) {\n                                tmpArray.push(directClone(child));\n                            }\n                        }\n                        newProps.children = tmpArray;\n                    }\n                }\n                else if (isVNode(newChildren)) {\n                    newProps.children = directClone(newChildren);\n                }\n            }\n        }\n        newVNode.children = null;\n    }\n    else if (flags & 3970 /* Element */) {\n        var children = vNodeToClone.children;\n        var props = void 0;\n        var propsToClone = vNodeToClone.props;\n        if (!propsToClone) {\n            props = utils_1.EMPTY_OBJ;\n        }\n        else {\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, props, vNodeToClone.key, vNodeToClone.ref, !children);\n    }\n    else if (flags & 1 /* Text */) {\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\n    }\n    return newVNode;\n}\nexports.directClone = directClone;\n/*\n directClone is preferred over cloneVNode and used internally also.\n This function makes Inferno backwards compatible.\n And can be tree-shaked by modern bundlers\n\n Would be nice to combine this with directClone but could not do it without breaking change\n */\n/**\n * Clones given virtual node by creating new instance of it\n * @param {VNode} vNodeToClone virtual node to be cloned\n * @param {Props=} props additional props for new virtual node\n * @param {...*} _children new children for new virtual node\n * @returns {VNode} new virtual node\n */\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        _children[_i - 2] = arguments[_i];\n    }\n    var children = _children;\n    var childrenLen = _children.length;\n    if (childrenLen > 0 && !inferno_shared_1.isUndefined(_children[0])) {\n        if (!props) {\n            props = {};\n        }\n        if (childrenLen === 1) {\n            children = _children[0];\n        }\n        if (!inferno_shared_1.isUndefined(children)) {\n            props.children = children;\n        }\n    }\n    var newVNode;\n    if (inferno_shared_1.isArray(vNodeToClone)) {\n        var tmpArray = [];\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\n            tmpArray.push(directClone(vNodeToClone[i]));\n        }\n        newVNode = tmpArray;\n    }\n    else {\n        var flags = vNodeToClone.flags;\n        var className = vNodeToClone.className || (props && props.className);\n        var key = !inferno_shared_1.isNullOrUndef(vNodeToClone.key) ? vNodeToClone.key : (props ? props.key : null);\n        var ref = vNodeToClone.ref || (props ? props.ref : null);\n        if (flags & 28 /* Component */) {\n            newVNode = createVNode(flags, vNodeToClone.type, className, null, (!vNodeToClone.props && !props) ? utils_1.EMPTY_OBJ : inferno_shared_1.combineFrom(vNodeToClone.props, props), key, ref, true);\n            var newProps = newVNode.props;\n            if (newProps) {\n                var newChildren = newProps.children;\n                // we need to also clone component children that are in props\n                // as the children may also have been hoisted\n                if (newChildren) {\n                    if (inferno_shared_1.isArray(newChildren)) {\n                        var len = newChildren.length;\n                        if (len > 0) {\n                            var tmpArray = [];\n                            for (var i = 0; i < len; i++) {\n                                var child = newChildren[i];\n                                if (inferno_shared_1.isStringOrNumber(child)) {\n                                    tmpArray.push(child);\n                                }\n                                else if (!inferno_shared_1.isInvalid(child) && isVNode(child)) {\n                                    tmpArray.push(directClone(child));\n                                }\n                            }\n                            newProps.children = tmpArray;\n                        }\n                    }\n                    else if (isVNode(newChildren)) {\n                        newProps.children = directClone(newChildren);\n                    }\n                }\n            }\n            newVNode.children = null;\n        }\n        else if (flags & 3970 /* Element */) {\n            children = (props && !inferno_shared_1.isUndefined(props.children)) ? props.children : vNodeToClone.children;\n            newVNode = createVNode(flags, vNodeToClone.type, className, children, (!vNodeToClone.props && !props) ? utils_1.EMPTY_OBJ : inferno_shared_1.combineFrom(vNodeToClone.props, props), key, ref, !children);\n        }\n        else if (flags & 1 /* Text */) {\n            newVNode = createTextVNode(vNodeToClone.children, key);\n        }\n    }\n    return newVNode;\n}\nexports.cloneVNode = cloneVNode;\nfunction createVoidVNode() {\n    return createVNode(4096 /* Void */, null);\n}\nexports.createVoidVNode = createVoidVNode;\nfunction createTextVNode(text, key) {\n    return createVNode(1 /* Text */, null, null, text, null, key);\n}\nexports.createTextVNode = createTextVNode;\nfunction isVNode(o) {\n    return !!o.flags;\n}\nexports.isVNode = isVNode;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/utils.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar options_1 = require(\"../core/options\");\nvar VNodes_1 = require(\"../core/VNodes\");\nvar constants_1 = require(\"./constants\");\nvar mounting_1 = require(\"./mounting\");\nvar unmounting_1 = require(\"./unmounting\");\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nexports.EMPTY_OBJ = {};\nif (process.env.NODE_ENV !== 'production') {\n    Object.freeze(exports.EMPTY_OBJ);\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    if (inferno_shared_1.isUndefined(context)) {\n        context = exports.EMPTY_OBJ; // Context should not be mutable\n    }\n    var instance = new Component(props, context);\n    vNode.children = instance;\n    instance._blockSetState = false;\n    instance.context = context;\n    if (instance.props === exports.EMPTY_OBJ) {\n        instance.props = props;\n    }\n    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount\n    instance._lifecycle = lifecycle;\n    instance._unmounted = false;\n    instance._pendingSetState = true;\n    instance._isSVG = isSVG;\n    if (!inferno_shared_1.isUndefined(instance.componentWillMount)) {\n        instance._blockRender = true;\n        instance.componentWillMount();\n        instance._blockRender = false;\n    }\n    var childContext;\n    if (!inferno_shared_1.isUndefined(instance.getChildContext)) {\n        childContext = instance.getChildContext();\n    }\n    if (inferno_shared_1.isNullOrUndef(childContext)) {\n        instance._childContext = context;\n    }\n    else {\n        instance._childContext = inferno_shared_1.combineFrom(context, childContext);\n    }\n    if (!inferno_shared_1.isNull(options_1.options.beforeRender)) {\n        options_1.options.beforeRender(instance);\n    }\n    var input = instance.render(props, instance.state, context);\n    if (!inferno_shared_1.isNull(options_1.options.afterRender)) {\n        options_1.options.afterRender(instance);\n    }\n    if (inferno_shared_1.isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        inferno_shared_1.throwError();\n    }\n    else if (inferno_shared_1.isInvalid(input)) {\n        input = VNodes_1.createVoidVNode();\n    }\n    else if (inferno_shared_1.isStringOrNumber(input)) {\n        input = VNodes_1.createTextVNode(input, null);\n    }\n    else {\n        if (input.dom) {\n            input = VNodes_1.directClone(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    instance._pendingSetState = false;\n    instance._lastInput = input;\n    return instance;\n}\nexports.createClassComponentInstance = createClassComponentInstance;\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\n    replaceVNode(parentDom, mounting_1.mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\n}\nexports.replaceLastChildAndUnmount = replaceLastChildAndUnmount;\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\n    unmounting_1.unmount(vNode, null, lifecycle, false, isRecycling);\n    replaceChild(parentDom, dom, vNode.dom);\n}\nexports.replaceVNode = replaceVNode;\nfunction createFunctionalComponentInput(vNode, component, props, context) {\n    var input = component(props, context);\n    if (inferno_shared_1.isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        inferno_shared_1.throwError();\n    }\n    else if (inferno_shared_1.isInvalid(input)) {\n        input = VNodes_1.createVoidVNode();\n    }\n    else if (inferno_shared_1.isStringOrNumber(input)) {\n        input = VNodes_1.createTextVNode(input, null);\n    }\n    else {\n        if (input.dom) {\n            input = VNodes_1.directClone(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    return input;\n}\nexports.createFunctionalComponentInput = createFunctionalComponentInput;\nfunction setTextContent(dom, text) {\n    if (text !== '') {\n        dom.textContent = text;\n    }\n    else {\n        dom.appendChild(document.createTextNode(''));\n    }\n}\nexports.setTextContent = setTextContent;\nfunction updateTextContent(dom, text) {\n    dom.firstChild.nodeValue = text;\n}\nexports.updateTextContent = updateTextContent;\nfunction appendChild(parentDom, dom) {\n    parentDom.appendChild(dom);\n}\nexports.appendChild = appendChild;\nfunction insertOrAppend(parentDom, newNode, nextNode) {\n    if (inferno_shared_1.isNullOrUndef(nextNode)) {\n        appendChild(parentDom, newNode);\n    }\n    else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\nexports.insertOrAppend = insertOrAppend;\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG === true) {\n        return document.createElementNS(constants_1.svgNS, tag);\n    }\n    else {\n        return document.createElement(tag);\n    }\n}\nexports.documentCreateElement = documentCreateElement;\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    unmounting_1.unmount(lastNode, null, lifecycle, false, isRecycling);\n    var dom = mounting_1.mount(nextNode, null, lifecycle, context, isSVG);\n    nextNode.dom = dom;\n    replaceChild(parentDom, dom, lastNode.dom);\n}\nexports.replaceWithNewNode = replaceWithNewNode;\nfunction replaceChild(parentDom, nextDom, lastDom) {\n    if (!parentDom) {\n        parentDom = lastDom.parentNode;\n    }\n    parentDom.replaceChild(nextDom, lastDom);\n}\nexports.replaceChild = replaceChild;\nfunction removeChild(parentDom, dom) {\n    parentDom.removeChild(dom);\n}\nexports.removeChild = removeChild;\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\n    dom.textContent = '';\n    if (!options_1.options.recyclingEnabled || (options_1.options.recyclingEnabled && !isRecycling)) {\n        removeChildren(null, children, lifecycle, isRecycling);\n    }\n}\nexports.removeAllChildren = removeAllChildren;\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\n    for (var i = 0, len = children.length; i < len; i++) {\n        var child = children[i];\n        if (!inferno_shared_1.isInvalid(child)) {\n            unmounting_1.unmount(child, dom, lifecycle, true, isRecycling);\n        }\n    }\n}\nexports.removeChildren = removeChildren;\nfunction isKeyed(lastChildren, nextChildren) {\n    return nextChildren.length > 0 && !inferno_shared_1.isNullOrUndef(nextChildren[0]) && !inferno_shared_1.isNullOrUndef(nextChildren[0].key)\n        && lastChildren.length > 0 && !inferno_shared_1.isNullOrUndef(lastChildren[0]) && !inferno_shared_1.isNullOrUndef(lastChildren[0].key);\n}\nexports.isKeyed = isKeyed;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/core/options.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.options = {\n    afterMount: null,\n    afterRender: null,\n    afterUpdate: null,\n    beforeRender: null,\n    beforeUnmount: null,\n    createVNode: null,\n    findDOMNodeEnabled: false,\n    recyclingEnabled: false,\n    roots: []\n};\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/constants.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.xlinkNS = 'http://www.w3.org/1999/xlink';\nexports.xmlNS = 'http://www.w3.org/XML/1998/namespace';\nexports.svgNS = 'http://www.w3.org/2000/svg';\nexports.strictProps = new Set();\nexports.strictProps.add('volume');\nexports.strictProps.add('defaultChecked');\nexports.booleanProps = new Set();\nexports.booleanProps.add('muted');\nexports.booleanProps.add('scoped');\nexports.booleanProps.add('loop');\nexports.booleanProps.add('open');\nexports.booleanProps.add('checked');\nexports.booleanProps.add('default');\nexports.booleanProps.add('capture');\nexports.booleanProps.add('disabled');\nexports.booleanProps.add('readOnly');\nexports.booleanProps.add('required');\nexports.booleanProps.add('autoplay');\nexports.booleanProps.add('controls');\nexports.booleanProps.add('seamless');\nexports.booleanProps.add('reversed');\nexports.booleanProps.add('allowfullscreen');\nexports.booleanProps.add('novalidate');\nexports.booleanProps.add('hidden');\nexports.booleanProps.add('autoFocus');\nexports.namespaces = new Map();\nexports.namespaces.set('xlink:href', exports.xlinkNS);\nexports.namespaces.set('xlink:arcrole', exports.xlinkNS);\nexports.namespaces.set('xlink:actuate', exports.xlinkNS);\nexports.namespaces.set('xlink:show', exports.xlinkNS);\nexports.namespaces.set('xlink:role', exports.xlinkNS);\nexports.namespaces.set('xlink:title', exports.xlinkNS);\nexports.namespaces.set('xlink:type', exports.xlinkNS);\nexports.namespaces.set('xml:base', exports.xmlNS);\nexports.namespaces.set('xml:lang', exports.xmlNS);\nexports.namespaces.set('xml:space', exports.xmlNS);\nexports.isUnitlessNumber = new Set();\nexports.isUnitlessNumber.add('animationIterationCount');\nexports.isUnitlessNumber.add('borderImageOutset');\nexports.isUnitlessNumber.add('borderImageSlice');\nexports.isUnitlessNumber.add('borderImageWidth');\nexports.isUnitlessNumber.add('boxFlex');\nexports.isUnitlessNumber.add('boxFlexGroup');\nexports.isUnitlessNumber.add('boxOrdinalGroup');\nexports.isUnitlessNumber.add('columnCount');\nexports.isUnitlessNumber.add('flex');\nexports.isUnitlessNumber.add('flexGrow');\nexports.isUnitlessNumber.add('flexPositive');\nexports.isUnitlessNumber.add('flexShrink');\nexports.isUnitlessNumber.add('flexNegative');\nexports.isUnitlessNumber.add('flexOrder');\nexports.isUnitlessNumber.add('gridRow');\nexports.isUnitlessNumber.add('gridColumn');\nexports.isUnitlessNumber.add('fontWeight');\nexports.isUnitlessNumber.add('lineClamp');\nexports.isUnitlessNumber.add('lineHeight');\nexports.isUnitlessNumber.add('opacity');\nexports.isUnitlessNumber.add('order');\nexports.isUnitlessNumber.add('orphans');\nexports.isUnitlessNumber.add('tabSize');\nexports.isUnitlessNumber.add('widows');\nexports.isUnitlessNumber.add('zIndex');\nexports.isUnitlessNumber.add('zoom');\nexports.isUnitlessNumber.add('fillOpacity');\nexports.isUnitlessNumber.add('floodOpacity');\nexports.isUnitlessNumber.add('stopOpacity');\nexports.isUnitlessNumber.add('strokeDasharray');\nexports.isUnitlessNumber.add('strokeDashoffset');\nexports.isUnitlessNumber.add('strokeMiterlimit');\nexports.isUnitlessNumber.add('strokeOpacity');\nexports.isUnitlessNumber.add('strokeWidth');\nexports.skipProps = new Set();\nexports.skipProps.add('children');\nexports.skipProps.add('childrenType');\nexports.skipProps.add('defaultValue');\nexports.skipProps.add('ref');\nexports.skipProps.add('key');\nexports.skipProps.add('selected');\nexports.skipProps.add('checked');\nexports.skipProps.add('multiple');\nexports.delegatedEvents = new Set();\nexports.delegatedEvents.add('onClick');\nexports.delegatedEvents.add('onMouseDown');\nexports.delegatedEvents.add('onMouseUp');\nexports.delegatedEvents.add('onMouseMove');\nexports.delegatedEvents.add('onSubmit');\nexports.delegatedEvents.add('onDblClick');\nexports.delegatedEvents.add('onKeyDown');\nexports.delegatedEvents.add('onKeyUp');\nexports.delegatedEvents.add('onKeyPress');\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/mounting.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar options_1 = require(\"../core/options\");\nvar VNodes_1 = require(\"../core/VNodes\");\nvar patching_1 = require(\"./patching\");\nvar recycling_1 = require(\"./recycling\");\nvar rendering_1 = require(\"./rendering\");\nvar utils_1 = require(\"./utils\");\nvar processElement_1 = require(\"./wrappers/processElement\");\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 3970 /* Element */) {\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\n    }\n    else if (flags & 28 /* Component */) {\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 4096 /* Void */) {\n        return mountVoid(vNode, parentDom);\n    }\n    else if (flags & 1 /* Text */) {\n        return mountText(vNode, parentDom);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof vNode === 'object') {\n                inferno_shared_1.throwError(\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + JSON.stringify(vNode) + \"\\\".\");\n            }\n            else {\n                inferno_shared_1.throwError(\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + typeof vNode + \"\\\".\");\n            }\n        }\n        inferno_shared_1.throwError();\n    }\n}\nexports.mount = mount;\nfunction mountText(vNode, parentDom) {\n    var dom = document.createTextNode(vNode.children);\n    vNode.dom = dom;\n    if (!inferno_shared_1.isNull(parentDom)) {\n        utils_1.appendChild(parentDom, dom);\n    }\n    return dom;\n}\nexports.mountText = mountText;\nfunction mountVoid(vNode, parentDom) {\n    var dom = document.createTextNode('');\n    vNode.dom = dom;\n    if (!inferno_shared_1.isNull(parentDom)) {\n        utils_1.appendChild(parentDom, dom);\n    }\n    return dom;\n}\nexports.mountVoid = mountVoid;\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\n    if (options_1.options.recyclingEnabled) {\n        var dom_1 = recycling_1.recycleElement(vNode, lifecycle, context, isSVG);\n        if (!inferno_shared_1.isNull(dom_1)) {\n            if (!inferno_shared_1.isNull(parentDom)) {\n                utils_1.appendChild(parentDom, dom_1);\n            }\n            return dom_1;\n        }\n    }\n    var flags = vNode.flags;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    var dom = utils_1.documentCreateElement(vNode.type, isSVG);\n    var children = vNode.children;\n    var props = vNode.props;\n    var className = vNode.className;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    if (!inferno_shared_1.isInvalid(children)) {\n        if (inferno_shared_1.isStringOrNumber(children)) {\n            utils_1.setTextContent(dom, children);\n        }\n        else if (inferno_shared_1.isArray(children)) {\n            mountArrayChildren(children, dom, lifecycle, context, isSVG);\n        }\n        else if (VNodes_1.isVNode(children)) {\n            mount(children, dom, lifecycle, context, isSVG);\n        }\n    }\n    if (!inferno_shared_1.isNull(props)) {\n        var hasControlledValue = false;\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\n        if (isFormElement) {\n            hasControlledValue = processElement_1.isControlledFormElement(props);\n        }\n        for (var prop in props) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patching_1.patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\n        }\n        if (isFormElement) {\n            processElement_1.processElement(flags, vNode, dom, props, true, hasControlledValue);\n        }\n    }\n    if (className !== null) {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (!inferno_shared_1.isNull(ref)) {\n        mountRef(dom, ref, lifecycle);\n    }\n    if (!inferno_shared_1.isNull(parentDom)) {\n        utils_1.appendChild(parentDom, dom);\n    }\n    return dom;\n}\nexports.mountElement = mountElement;\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\n    for (var i = 0, len = children.length; i < len; i++) {\n        var child = children[i];\n        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.\n        if (!inferno_shared_1.isInvalid(child)) {\n            if (child.dom) {\n                children[i] = child = VNodes_1.directClone(child);\n            }\n            mount(children[i], dom, lifecycle, context, isSVG);\n        }\n    }\n}\nexports.mountArrayChildren = mountArrayChildren;\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\n    if (options_1.options.recyclingEnabled) {\n        var dom_2 = recycling_1.recycleComponent(vNode, lifecycle, context, isSVG);\n        if (!inferno_shared_1.isNull(dom_2)) {\n            if (!inferno_shared_1.isNull(parentDom)) {\n                utils_1.appendChild(parentDom, dom_2);\n            }\n            return dom_2;\n        }\n    }\n    var type = vNode.type;\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    var ref = vNode.ref;\n    var dom;\n    if (isClass) {\n        var instance = utils_1.createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);\n        var input = instance._lastInput;\n        instance._vNode = vNode;\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\n        if (!inferno_shared_1.isNull(parentDom)) {\n            utils_1.appendChild(parentDom, dom);\n        }\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        instance._updating = false;\n        if (options_1.options.findDOMNodeEnabled) {\n            rendering_1.componentToDOMNodeMap.set(instance, dom);\n        }\n    }\n    else {\n        var input = utils_1.createFunctionalComponentInput(vNode, type, props, context);\n        vNode.dom = dom = mount(input, null, lifecycle, context, isSVG);\n        vNode.children = input;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n        if (!inferno_shared_1.isNull(parentDom)) {\n            utils_1.appendChild(parentDom, dom);\n        }\n    }\n    return dom;\n}\nexports.mountComponent = mountComponent;\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\n    if (ref) {\n        if (inferno_shared_1.isFunction(ref)) {\n            ref(instance);\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                if (inferno_shared_1.isStringOrNumber(ref)) {\n                    inferno_shared_1.throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n                }\n                else if (inferno_shared_1.isObject(ref) && (vNode.flags & 4 /* ComponentClass */)) {\n                    inferno_shared_1.throwError('functional component lifecycle events are not supported on ES2015 class components.');\n                }\n                else {\n                    inferno_shared_1.throwError(\"a bad value for \\\"ref\\\" was used on component: \\\"\" + JSON.stringify(ref) + \"\\\"\");\n                }\n            }\n            inferno_shared_1.throwError();\n        }\n    }\n    var hasDidMount = !inferno_shared_1.isUndefined(instance.componentDidMount);\n    var afterMount = options_1.options.afterMount;\n    if (hasDidMount || !inferno_shared_1.isNull(afterMount)) {\n        lifecycle.addListener(function () {\n            instance._updating = true;\n            if (afterMount) {\n                afterMount(vNode);\n            }\n            if (hasDidMount) {\n                instance.componentDidMount();\n            }\n            instance._updating = false;\n        });\n    }\n}\nexports.mountClassComponentCallbacks = mountClassComponentCallbacks;\nfunction mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\n    if (ref) {\n        if (!inferno_shared_1.isNullOrUndef(ref.onComponentWillMount)) {\n            ref.onComponentWillMount();\n        }\n        if (!inferno_shared_1.isNullOrUndef(ref.onComponentDidMount)) {\n            lifecycle.addListener(function () { return ref.onComponentDidMount(dom); });\n        }\n    }\n}\nexports.mountFunctionalComponentCallbacks = mountFunctionalComponentCallbacks;\nfunction mountRef(dom, value, lifecycle) {\n    if (inferno_shared_1.isFunction(value)) {\n        lifecycle.addListener(function () { return value(dom); });\n    }\n    else {\n        if (inferno_shared_1.isInvalid(value)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        inferno_shared_1.throwError();\n    }\n}\nexports.mountRef = mountRef;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/patching.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar options_1 = require(\"../core/options\");\nvar VNodes_1 = require(\"../core/VNodes\");\nvar constants_1 = require(\"./constants\");\nvar delegation_1 = require(\"./events/delegation\");\nvar mounting_1 = require(\"./mounting\");\nvar rendering_1 = require(\"./rendering\");\nvar unmounting_1 = require(\"./unmounting\");\nvar utils_1 = require(\"./utils\");\nvar processElement_1 = require(\"./wrappers/processElement\");\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    if (lastVNode !== nextVNode) {\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        if (nextFlags & 28 /* Component */) {\n            if (lastFlags & 28 /* Component */) {\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */, isRecycling);\n            }\n            else {\n                utils_1.replaceVNode(parentDom, mounting_1.mountComponent(nextVNode, null, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 3970 /* Element */) {\n            if (lastFlags & 3970 /* Element */) {\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n            }\n            else {\n                utils_1.replaceVNode(parentDom, mounting_1.mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 1 /* Text */) {\n            if (lastFlags & 1 /* Text */) {\n                patchText(lastVNode, nextVNode);\n            }\n            else {\n                utils_1.replaceVNode(parentDom, mounting_1.mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 4096 /* Void */) {\n            if (lastFlags & 4096 /* Void */) {\n                patchVoid(lastVNode, nextVNode);\n            }\n            else {\n                utils_1.replaceVNode(parentDom, mounting_1.mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else {\n            // Error case: mount new one replacing old one\n            utils_1.replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nexports.patch = patch;\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\n    if (VNodes_1.isVNode(children)) {\n        unmounting_1.unmount(children, dom, lifecycle, true, isRecycling);\n    }\n    else if (inferno_shared_1.isArray(children)) {\n        utils_1.removeAllChildren(dom, children, lifecycle, isRecycling);\n    }\n    else {\n        dom.textContent = '';\n    }\n}\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    var nextTag = nextVNode.type;\n    var lastTag = lastVNode.type;\n    if (lastTag !== nextTag) {\n        utils_1.replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n    }\n    else {\n        var dom = lastVNode.dom;\n        var lastProps = lastVNode.props;\n        var nextProps = nextVNode.props;\n        var lastChildren = lastVNode.children;\n        var nextChildren = nextVNode.children;\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        var nextRef = nextVNode.ref;\n        var lastClassName = lastVNode.className;\n        var nextClassName = nextVNode.className;\n        nextVNode.dom = dom;\n        if (isSVG || (nextFlags & 128 /* SvgElement */) > 0) {\n            isSVG = true;\n        }\n        if (lastChildren !== nextChildren) {\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        // inlined patchProps  -- starts --\n        if (lastProps !== nextProps) {\n            var lastPropsOrEmpty = lastProps || utils_1.EMPTY_OBJ;\n            var nextPropsOrEmpty = nextProps || utils_1.EMPTY_OBJ;\n            var hasControlledValue = false;\n            if (nextPropsOrEmpty !== utils_1.EMPTY_OBJ) {\n                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;\n                if (isFormElement) {\n                    hasControlledValue = processElement_1.isControlledFormElement(nextPropsOrEmpty);\n                }\n                for (var prop in nextPropsOrEmpty) {\n                    // do not add a hasOwnProperty check here, it affects performance\n                    var nextValue = nextPropsOrEmpty[prop];\n                    var lastValue = lastPropsOrEmpty[prop];\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\n                }\n                if (isFormElement) {\n                    processElement_1.processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n                }\n            }\n            if (lastPropsOrEmpty !== utils_1.EMPTY_OBJ) {\n                for (var prop in lastPropsOrEmpty) {\n                    // do not add a hasOwnProperty check here, it affects performance\n                    if (inferno_shared_1.isNullOrUndef(nextPropsOrEmpty[prop])) {\n                        removeProp(prop, lastPropsOrEmpty[prop], dom);\n                    }\n                }\n            }\n        }\n        // inlined patchProps  -- ends --\n        if (lastClassName !== nextClassName) {\n            if (inferno_shared_1.isNullOrUndef(nextClassName)) {\n                dom.removeAttribute('class');\n            }\n            else {\n                if (isSVG) {\n                    dom.setAttribute('class', nextClassName);\n                }\n                else {\n                    dom.className = nextClassName;\n                }\n            }\n        }\n        if (nextRef) {\n            if (lastVNode.ref !== nextRef || isRecycling) {\n                mounting_1.mountRef(dom, nextRef, lifecycle);\n            }\n        }\n    }\n}\nexports.patchElement = patchElement;\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var patchArray = false;\n    var patchKeyed = false;\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\n        patchArray = true;\n    }\n    else if ((lastFlags & 32 /* HasKeyedChildren */) && (nextFlags & 32 /* HasKeyedChildren */)) {\n        patchKeyed = true;\n        patchArray = true;\n    }\n    else if (inferno_shared_1.isInvalid(nextChildren)) {\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n    }\n    else if (inferno_shared_1.isInvalid(lastChildren)) {\n        if (inferno_shared_1.isStringOrNumber(nextChildren)) {\n            utils_1.setTextContent(dom, nextChildren);\n        }\n        else {\n            if (inferno_shared_1.isArray(nextChildren)) {\n                mounting_1.mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n            }\n            else {\n                mounting_1.mount(nextChildren, dom, lifecycle, context, isSVG);\n            }\n        }\n    }\n    else if (inferno_shared_1.isStringOrNumber(nextChildren)) {\n        if (inferno_shared_1.isStringOrNumber(lastChildren)) {\n            utils_1.updateTextContent(dom, nextChildren);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            utils_1.setTextContent(dom, nextChildren);\n        }\n    }\n    else if (inferno_shared_1.isArray(nextChildren)) {\n        if (inferno_shared_1.isArray(lastChildren)) {\n            patchArray = true;\n            if (utils_1.isKeyed(lastChildren, nextChildren)) {\n                patchKeyed = true;\n            }\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mounting_1.mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    }\n    else if (inferno_shared_1.isArray(lastChildren)) {\n        utils_1.removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n        mounting_1.mount(nextChildren, dom, lifecycle, context, isSVG);\n    }\n    else if (VNodes_1.isVNode(nextChildren)) {\n        if (VNodes_1.isVNode(lastChildren)) {\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mounting_1.mount(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    }\n    if (patchArray) {\n        if (patchKeyed) {\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\n    var lastType = lastVNode.type;\n    var nextType = nextVNode.type;\n    var lastKey = lastVNode.key;\n    var nextKey = nextVNode.key;\n    if (lastType !== nextType || lastKey !== nextKey) {\n        utils_1.replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        return false;\n    }\n    else {\n        var nextProps = nextVNode.props || utils_1.EMPTY_OBJ;\n        if (isClass) {\n            var instance = lastVNode.children;\n            instance._updating = true;\n            if (instance._unmounted) {\n                if (inferno_shared_1.isNull(parentDom)) {\n                    return true;\n                }\n                utils_1.replaceChild(parentDom, mounting_1.mountComponent(nextVNode, null, lifecycle, context, isSVG, nextVNode.flags & 4 /* ComponentClass */), lastVNode.dom);\n            }\n            else {\n                var hasComponentDidUpdate = !inferno_shared_1.isUndefined(instance.componentDidUpdate);\n                var nextState = instance.state;\n                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update\n                var lastState = hasComponentDidUpdate ? inferno_shared_1.combineFrom(nextState, null) : nextState;\n                var lastProps = instance.props;\n                var childContext = void 0;\n                if (!inferno_shared_1.isUndefined(instance.getChildContext)) {\n                    childContext = instance.getChildContext();\n                }\n                nextVNode.children = instance;\n                instance._isSVG = isSVG;\n                if (inferno_shared_1.isNullOrUndef(childContext)) {\n                    childContext = context;\n                }\n                else {\n                    childContext = inferno_shared_1.combineFrom(context, childContext);\n                }\n                var lastInput = instance._lastInput;\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\n                var didUpdate = true;\n                instance._childContext = childContext;\n                if (inferno_shared_1.isInvalid(nextInput)) {\n                    nextInput = VNodes_1.createVoidVNode();\n                }\n                else if (nextInput === inferno_shared_1.NO_OP) {\n                    nextInput = lastInput;\n                    didUpdate = false;\n                }\n                else if (inferno_shared_1.isStringOrNumber(nextInput)) {\n                    nextInput = VNodes_1.createTextVNode(nextInput, null);\n                }\n                else if (inferno_shared_1.isArray(nextInput)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        inferno_shared_1.throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    inferno_shared_1.throwError();\n                }\n                else if (inferno_shared_1.isObject(nextInput)) {\n                    if (!inferno_shared_1.isNull(nextInput.dom)) {\n                        nextInput = VNodes_1.directClone(nextInput);\n                    }\n                }\n                if (nextInput.flags & 28 /* Component */) {\n                    nextInput.parentVNode = nextVNode;\n                }\n                else if (lastInput.flags & 28 /* Component */) {\n                    lastInput.parentVNode = nextVNode;\n                }\n                instance._lastInput = nextInput;\n                instance._vNode = nextVNode;\n                if (didUpdate) {\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\n                    if (hasComponentDidUpdate) {\n                        instance.componentDidUpdate(lastProps, lastState);\n                    }\n                    if (!inferno_shared_1.isNull(options_1.options.afterUpdate)) {\n                        options_1.options.afterUpdate(nextVNode);\n                    }\n                    if (options_1.options.findDOMNodeEnabled) {\n                        rendering_1.componentToDOMNodeMap.set(instance, nextInput.dom);\n                    }\n                }\n                nextVNode.dom = nextInput.dom;\n            }\n            instance._updating = false;\n        }\n        else {\n            var shouldUpdate = true;\n            var lastProps = lastVNode.props;\n            var nextHooks = nextVNode.ref;\n            var nextHooksDefined = !inferno_shared_1.isNullOrUndef(nextHooks);\n            var lastInput = lastVNode.children;\n            var nextInput = lastInput;\n            nextVNode.dom = lastVNode.dom;\n            nextVNode.children = lastInput;\n            if (lastKey !== nextKey) {\n                shouldUpdate = true;\n            }\n            else {\n                if (nextHooksDefined && !inferno_shared_1.isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps, nextProps);\n                }\n            }\n            if (shouldUpdate !== false) {\n                if (nextHooksDefined && !inferno_shared_1.isNullOrUndef(nextHooks.onComponentWillUpdate)) {\n                    nextHooks.onComponentWillUpdate(lastProps, nextProps);\n                }\n                nextInput = nextType(nextProps, context);\n                if (inferno_shared_1.isInvalid(nextInput)) {\n                    nextInput = VNodes_1.createVoidVNode();\n                }\n                else if (inferno_shared_1.isStringOrNumber(nextInput) && nextInput !== inferno_shared_1.NO_OP) {\n                    nextInput = VNodes_1.createTextVNode(nextInput, null);\n                }\n                else if (inferno_shared_1.isArray(nextInput)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        inferno_shared_1.throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    inferno_shared_1.throwError();\n                }\n                else if (inferno_shared_1.isObject(nextInput)) {\n                    if (!inferno_shared_1.isNull(nextInput.dom)) {\n                        nextInput = VNodes_1.directClone(nextInput);\n                    }\n                }\n                if (nextInput !== inferno_shared_1.NO_OP) {\n                    patch(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling);\n                    nextVNode.children = nextInput;\n                    if (nextHooksDefined && !inferno_shared_1.isNullOrUndef(nextHooks.onComponentDidUpdate)) {\n                        nextHooks.onComponentDidUpdate(lastProps, nextProps);\n                    }\n                    nextVNode.dom = nextInput.dom;\n                }\n            }\n            if (nextInput.flags & 28 /* Component */) {\n                nextInput.parentVNode = nextVNode;\n            }\n            else if (lastInput.flags & 28 /* Component */) {\n                lastInput.parentVNode = nextVNode;\n            }\n        }\n    }\n    return false;\n}\nexports.patchComponent = patchComponent;\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    nextVNode.dom = dom;\n    if (lastVNode.children !== nextText) {\n        dom.nodeValue = nextText;\n    }\n}\nexports.patchText = patchText;\nfunction patchVoid(lastVNode, nextVNode) {\n    nextVNode.dom = lastVNode.dom;\n}\nexports.patchVoid = patchVoid;\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var lastChildrenLength = lastChildren.length;\n    var nextChildrenLength = nextChildren.length;\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    for (; i < commonLength; i++) {\n        var nextChild = nextChildren[i];\n        if (nextChild.dom) {\n            nextChild = nextChildren[i] = VNodes_1.directClone(nextChild);\n        }\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; i++) {\n            var nextChild = nextChildren[i];\n            if (nextChild.dom) {\n                nextChild = nextChildren[i] = VNodes_1.directClone(nextChild);\n            }\n            utils_1.appendChild(dom, mounting_1.mount(nextChild, null, lifecycle, context, isSVG));\n        }\n    }\n    else if (nextChildrenLength === 0) {\n        utils_1.removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; i++) {\n            unmounting_1.unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\n        }\n    }\n}\nexports.patchNonKeyedChildren = patchNonKeyedChildren;\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\n    var aLength = a.length;\n    var bLength = b.length;\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var aStart = 0;\n    var bStart = 0;\n    var i;\n    var j;\n    var aNode;\n    var bNode;\n    var nextNode;\n    var nextPos;\n    var node;\n    if (aLength === 0) {\n        if (bLength !== 0) {\n            mounting_1.mountArrayChildren(b, dom, lifecycle, context, isSVG);\n        }\n        return;\n    }\n    else if (bLength === 0) {\n        utils_1.removeAllChildren(dom, a, lifecycle, isRecycling);\n        return;\n    }\n    var aStartNode = a[aStart];\n    var bStartNode = b[bStart];\n    var aEndNode = a[aEnd];\n    var bEndNode = b[bEnd];\n    if (bStartNode.dom) {\n        b[bStart] = bStartNode = VNodes_1.directClone(bStartNode);\n    }\n    if (bEndNode.dom) {\n        b[bEnd] = bEndNode = VNodes_1.directClone(bEndNode);\n    }\n    // Step 1\n    /* eslint no-constant-condition: 0 */\n    outer: while (true) {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode.key === bStartNode.key) {\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = VNodes_1.directClone(bStartNode);\n            }\n        }\n        // Sync nodes with the same key at the end.\n        while (aEndNode.key === bEndNode.key) {\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = VNodes_1.directClone(bEndNode);\n            }\n        }\n        // Move and sync nodes from right to left.\n        if (aEndNode.key === bStartNode.key) {\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            utils_1.insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\n            aEnd--;\n            bStart++;\n            aEndNode = a[aEnd];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = VNodes_1.directClone(bStartNode);\n            }\n            continue;\n        }\n        // Move and sync nodes from left to right.\n        if (aStartNode.key === bEndNode.key) {\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            utils_1.insertOrAppend(dom, bEndNode.dom, nextNode);\n            aStart++;\n            bEnd--;\n            aStartNode = a[aStart];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = VNodes_1.directClone(bEndNode);\n            }\n            continue;\n        }\n        break;\n    }\n    if (aStart > aEnd) {\n        if (bStart <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            while (bStart <= bEnd) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = VNodes_1.directClone(node);\n                }\n                bStart++;\n                utils_1.insertOrAppend(dom, mounting_1.mount(node, null, lifecycle, context, isSVG), nextNode);\n            }\n        }\n    }\n    else if (bStart > bEnd) {\n        while (aStart <= aEnd) {\n            unmounting_1.unmount(a[aStart++], dom, lifecycle, false, isRecycling);\n        }\n    }\n    else {\n        aLength = aEnd - aStart + 1;\n        bLength = bEnd - bStart + 1;\n        var sources = new Array(bLength);\n        // Mark all nodes as inserted.\n        for (i = 0; i < bLength; i++) {\n            sources[i] = -1;\n        }\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if ((bLength <= 4) || (aLength * bLength <= 16)) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i;\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.dom) {\n                                b[j] = bNode = VNodes_1.directClone(bNode);\n                            }\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                            patched++;\n                            a[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            var keyIndex = new Map();\n            // Map keys by their index in array\n            for (i = bStart; i <= bEnd; i++) {\n                keyIndex.set(b[i].key, i);\n            }\n            // Try to patch same keys\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    j = keyIndex.get(aNode.key);\n                    if (!inferno_shared_1.isUndefined(j)) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.dom) {\n                            b[j] = bNode = VNodes_1.directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                        patched++;\n                        a[i] = null;\n                    }\n                }\n            }\n        }\n        // fast-path: if nothing patched remove all old and add all new\n        if (aLength === a.length && patched === 0) {\n            utils_1.removeAllChildren(dom, a, lifecycle, isRecycling);\n            while (bStart < bLength) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = VNodes_1.directClone(node);\n                }\n                bStart++;\n                utils_1.insertOrAppend(dom, mounting_1.mount(node, null, lifecycle, context, isSVG), null);\n            }\n        }\n        else {\n            i = aLength - patched;\n            while (i > 0) {\n                aNode = a[aStart++];\n                if (!inferno_shared_1.isNull(aNode)) {\n                    unmounting_1.unmount(aNode, dom, lifecycle, true, isRecycling);\n                    i--;\n                }\n            }\n            if (moved) {\n                var seq = lis_algorithm(sources);\n                j = seq.length - 1;\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = VNodes_1.directClone(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        utils_1.insertOrAppend(dom, mounting_1.mount(node, dom, lifecycle, context, isSVG), nextNode);\n                    }\n                    else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                            utils_1.insertOrAppend(dom, node.dom, nextNode);\n                        }\n                        else {\n                            j--;\n                        }\n                    }\n                }\n            }\n            else if (patched !== bLength) {\n                // when patched count doesn't match b length we need to insert those new ones\n                // loop backwards so we can use insertBefore\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = VNodes_1.directClone(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        utils_1.insertOrAppend(dom, mounting_1.mount(node, null, lifecycle, context, isSVG), nextNode);\n                    }\n                }\n            }\n        }\n    }\n}\nexports.patchKeyedChildren = patchKeyedChildren;\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var p = arr.slice(0);\n    var result = [0];\n    var i;\n    var j;\n    var u;\n    var v;\n    var c;\n    var len = arr.length;\n    for (i = 0; i < len; i++) {\n        var arrI = arr[i];\n        if (arrI === -1) {\n            continue;\n        }\n        j = result[result.length - 1];\n        if (arr[j] < arrI) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n        u = 0;\n        v = result.length - 1;\n        while (u < v) {\n            c = ((u + v) / 2) | 0;\n            if (arr[result[c]] < arrI) {\n                u = c + 1;\n            }\n            else {\n                v = c;\n            }\n        }\n        if (arrI < arr[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n';\n}\nexports.isAttrAnEvent = isAttrAnEvent;\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\n    if (lastValue !== nextValue) {\n        if (constants_1.skipProps.has(prop) || (hasControlledValue && prop === 'value')) {\n            return;\n        }\n        else if (constants_1.booleanProps.has(prop)) {\n            prop = prop === 'autoFocus' ? prop.toLowerCase() : prop;\n            dom[prop] = !!nextValue;\n        }\n        else if (constants_1.strictProps.has(prop)) {\n            var value = inferno_shared_1.isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n        }\n        else if (isAttrAnEvent(prop)) {\n            patchEvent(prop, lastValue, nextValue, dom);\n        }\n        else if (inferno_shared_1.isNullOrUndef(nextValue)) {\n            dom.removeAttribute(prop);\n        }\n        else if (prop === 'style') {\n            patchStyle(lastValue, nextValue, dom);\n        }\n        else if (prop === 'dangerouslySetInnerHTML') {\n            var lastHtml = lastValue && lastValue.__html;\n            var nextHtml = nextValue && nextValue.__html;\n            if (lastHtml !== nextHtml) {\n                if (!inferno_shared_1.isNullOrUndef(nextHtml)) {\n                    dom.innerHTML = nextHtml;\n                }\n            }\n        }\n        else {\n            // We optimize for NS being boolean. Its 99.9% time false\n            if (isSVG && constants_1.namespaces.has(prop)) {\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(constants_1.namespaces.get(prop), prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n        }\n    }\n}\nexports.patchProp = patchProp;\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (lastValue !== nextValue) {\n        if (constants_1.delegatedEvents.has(name)) {\n            delegation_1.handleEvent(name, lastValue, nextValue, dom);\n        }\n        else {\n            var nameLowerCase = name.toLowerCase();\n            var domEvent = dom[nameLowerCase];\n            // if the function is wrapped, that means it's been controlled by a wrapper\n            if (domEvent && domEvent.wrapped) {\n                return;\n            }\n            if (!inferno_shared_1.isFunction(nextValue) && !inferno_shared_1.isNullOrUndef(nextValue)) {\n                var linkEvent_1 = nextValue.event;\n                if (linkEvent_1 && inferno_shared_1.isFunction(linkEvent_1)) {\n                    dom[nameLowerCase] = function (e) {\n                        linkEvent_1(nextValue.data, e);\n                    };\n                }\n                else {\n                    if (process.env.NODE_ENV !== 'production') {\n                        inferno_shared_1.throwError(\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\");\n                    }\n                    inferno_shared_1.throwError();\n                }\n            }\n            else {\n                dom[nameLowerCase] = nextValue;\n            }\n        }\n    }\n}\nexports.patchEvent = patchEvent;\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    var domStyle = dom.style;\n    if (inferno_shared_1.isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    for (var style in nextAttrValue) {\n        // do not add a hasOwnProperty check here, it affects performance\n        var value = nextAttrValue[style];\n        if (!inferno_shared_1.isNumber(value) || constants_1.isUnitlessNumber.has(style)) {\n            domStyle[style] = value;\n        }\n        else {\n            domStyle[style] = value + 'px';\n        }\n    }\n    if (!inferno_shared_1.isNullOrUndef(lastAttrValue)) {\n        for (var style in lastAttrValue) {\n            if (inferno_shared_1.isNullOrUndef(nextAttrValue[style])) {\n                domStyle[style] = '';\n            }\n        }\n    }\n}\nexports.patchStyle = patchStyle;\nfunction removeProp(prop, lastValue, dom) {\n    if (prop === 'value') {\n        dom.value = '';\n    }\n    else if (prop === 'style') {\n        dom.removeAttribute('style');\n    }\n    else if (isAttrAnEvent(prop)) {\n        delegation_1.handleEvent(prop, lastValue, null, dom);\n    }\n    else {\n        dom.removeAttribute(prop);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/events/delegation.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar isiOS = inferno_shared_1.isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\nvar delegatedEvents = new Map();\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\n    var delegatedRoots = delegatedEvents.get(name);\n    if (nextEvent) {\n        if (!delegatedRoots) {\n            delegatedRoots = { items: new Map(), docEvent: null };\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\n            delegatedEvents.set(name, delegatedRoots);\n        }\n        if (!lastEvent) {\n            if (isiOS && name === 'onClick') {\n                trapClickOnNonInteractiveElement(dom);\n            }\n        }\n        delegatedRoots.items.set(dom, nextEvent);\n    }\n    else if (delegatedRoots) {\n        var items = delegatedRoots.items;\n        if (items.delete(dom)) {\n            // If any items were deleted, check if listener need to be removed\n            if (items.size === 0) {\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\n                delegatedEvents.delete(name);\n            }\n        }\n    }\n}\nexports.handleEvent = handleEvent;\nfunction dispatchEvent(event, target, items, count, isClick, eventData) {\n    var eventsToTrigger = items.get(target);\n    if (eventsToTrigger) {\n        count--;\n        // linkEvent object\n        eventData.dom = target;\n        if (eventsToTrigger.event) {\n            eventsToTrigger.event(eventsToTrigger.data, event);\n        }\n        else {\n            eventsToTrigger(event);\n        }\n        if (event.cancelBubble) {\n            return;\n        }\n    }\n    if (count > 0) {\n        var parentDom = target.parentNode;\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (parentDom === null || (isClick && parentDom.nodeType === 1 && parentDom.disabled)) {\n            return;\n        }\n        dispatchEvent(event, parentDom, items, count, isClick, eventData);\n    }\n}\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    this.stopImmediatePropagation();\n}\nfunction attachEventToDocument(name, delegatedRoots) {\n    var docEvent = function (event) {\n        var count = delegatedRoots.items.size;\n        if (count > 0) {\n            event.stopPropagation = stopPropagation;\n            // Event data needs to be object to save reference to currentTarget getter\n            var eventData_1 = {\n                dom: document\n            };\n            try {\n                Object.defineProperty(event, 'currentTarget', {\n                    configurable: true,\n                    get: function get() {\n                        return eventData_1.dom;\n                    }\n                });\n            }\n            catch (e) { }\n            dispatchEvent(event, event.target, delegatedRoots.items, count, event.type === 'click', eventData_1);\n        }\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\n// tslint:disable-next-line:no-empty\nfunction emptyFn() { }\nfunction trapClickOnNonInteractiveElement(dom) {\n    // Mobile Safari does not fire properly bubble click events on\n    // non-interactive elements, which means delegated click listeners do not\n    // fire. The workaround for this bug involves attaching an empty click\n    // listener on the target node.\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n    // Just set it using the onclick property so that we don't have to manage any\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\n    // removed.\n    // TODO: Only do this for the relevant Safaris maybe?\n    dom.onclick = emptyFn;\n}\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/rendering.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar options_1 = require(\"../core/options\");\nvar VNodes_1 = require(\"../core/VNodes\");\nvar hydration_1 = require(\"./hydration\");\nvar mounting_1 = require(\"./mounting\");\nvar patching_1 = require(\"./patching\");\nvar unmounting_1 = require(\"./unmounting\");\nvar utils_1 = require(\"./utils\");\n// rather than use a Map, like we did before, we can use an array here\n// given there shouldn't be THAT many roots on the page, the difference\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\nexports.componentToDOMNodeMap = new Map();\nvar roots = options_1.options.roots;\n/**\n * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance\n * @param ref Component instance\n * @returns {*|null} returns dom node\n */\nfunction findDOMNode(ref) {\n    if (!options_1.options.findDOMNodeEnabled) {\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError('findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!');\n        }\n        inferno_shared_1.throwError();\n    }\n    var dom = ref && ref.nodeType ? ref : null;\n    return exports.componentToDOMNodeMap.get(ref) || dom;\n}\nexports.findDOMNode = findDOMNode;\nfunction getRoot(dom) {\n    for (var i = 0, len = roots.length; i < len; i++) {\n        var root = roots[i];\n        if (root.dom === dom) {\n            return root;\n        }\n    }\n    return null;\n}\nfunction setRoot(dom, input, lifecycle) {\n    var root = {\n        dom: dom,\n        input: input,\n        lifecycle: lifecycle\n    };\n    roots.push(root);\n    return root;\n}\nfunction removeRoot(root) {\n    for (var i = 0, len = roots.length; i < len; i++) {\n        if (roots[i] === root) {\n            roots.splice(i, 1);\n            return;\n        }\n    }\n}\nif (process.env.NODE_ENV !== 'production') {\n    if (inferno_shared_1.isBrowser && document.body === null) {\n        inferno_shared_1.warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\n    }\n}\nvar documentBody = inferno_shared_1.isBrowser ? document.body : null;\n/**\n * Renders virtual node tree into parent node.\n * @param {VNode | null | string | number} input vNode to be rendered\n * @param parentDom DOM node which content will be replaced by virtual node\n * @returns {InfernoChildren} rendered virtual node\n */\nfunction render(input, parentDom) {\n    if (documentBody === parentDom) {\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\n        }\n        inferno_shared_1.throwError();\n    }\n    if (input === inferno_shared_1.NO_OP) {\n        return;\n    }\n    var root = getRoot(parentDom);\n    if (inferno_shared_1.isNull(root)) {\n        var lifecycle = new inferno_shared_1.Lifecycle();\n        if (!inferno_shared_1.isInvalid(input)) {\n            if (input.dom) {\n                input = VNodes_1.directClone(input);\n            }\n            if (!hydration_1.hydrateRoot(input, parentDom, lifecycle)) {\n                mounting_1.mount(input, parentDom, lifecycle, utils_1.EMPTY_OBJ, false);\n            }\n            root = setRoot(parentDom, input, lifecycle);\n            lifecycle.trigger();\n        }\n    }\n    else {\n        var lifecycle = root.lifecycle;\n        lifecycle.listeners = [];\n        if (inferno_shared_1.isNullOrUndef(input)) {\n            unmounting_1.unmount(root.input, parentDom, lifecycle, false, false);\n            removeRoot(root);\n        }\n        else {\n            if (input.dom) {\n                input = VNodes_1.directClone(input);\n            }\n            patching_1.patch(root.input, input, parentDom, lifecycle, utils_1.EMPTY_OBJ, false, false);\n        }\n        root.input = input;\n        lifecycle.trigger();\n    }\n    if (root) {\n        var rootInput = root.input;\n        if (rootInput && (rootInput.flags & 28 /* Component */)) {\n            return rootInput.children;\n        }\n    }\n}\nexports.render = render;\nfunction createRenderer(parentDom) {\n    return function renderer(lastInput, nextInput) {\n        if (!parentDom) {\n            parentDom = lastInput;\n        }\n        render(nextInput, parentDom);\n    };\n}\nexports.createRenderer = createRenderer;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/hydration.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar options_1 = require(\"../core/options\");\nvar constants_1 = require(\"./constants\");\nvar mounting_1 = require(\"./mounting\");\nvar patching_1 = require(\"./patching\");\nvar rendering_1 = require(\"./rendering\");\nvar utils_1 = require(\"./utils\");\nvar processElement_1 = require(\"./wrappers/processElement\");\nfunction normalizeChildNodes(parentDom) {\n    var dom = parentDom.firstChild;\n    while (dom) {\n        if (dom.nodeType === 8) {\n            if (dom.data === '!') {\n                var placeholder = document.createTextNode('');\n                parentDom.replaceChild(placeholder, dom);\n                dom = dom.nextSibling;\n            }\n            else {\n                var lastDom = dom.previousSibling;\n                parentDom.removeChild(dom);\n                dom = lastDom || parentDom.firstChild;\n            }\n        }\n        else {\n            dom = dom.nextSibling;\n        }\n    }\n}\nexports.normalizeChildNodes = normalizeChildNodes;\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\n    var type = vNode.type;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    if (isClass) {\n        var _isSVG = dom.namespaceURI === constants_1.svgNS;\n        var instance = utils_1.createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);\n        var input = instance._lastInput;\n        instance._vComponent = vNode;\n        instance._vNode = vNode;\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\n        mounting_1.mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        instance._updating = false; // Mount finished allow going sync\n        if (options_1.options.findDOMNodeEnabled) {\n            rendering_1.componentToDOMNodeMap.set(instance, dom);\n        }\n    }\n    else {\n        var input = utils_1.createFunctionalComponentInput(vNode, type, props, context);\n        hydrate(input, dom, lifecycle, context, isSVG);\n        vNode.children = input;\n        vNode.dom = input.dom;\n        mounting_1.mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\n    var children = vNode.children;\n    var props = vNode.props;\n    var className = vNode.className;\n    var flags = vNode.flags;\n    var ref = vNode.ref;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.warning('Inferno hydration: Server-side markup doesn\\'t match client-side markup or Initial render target is not empty');\n        }\n        var newDom = mounting_1.mountElement(vNode, null, lifecycle, context, isSVG);\n        vNode.dom = newDom;\n        utils_1.replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    vNode.dom = dom;\n    if (children) {\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\n    }\n    if (props) {\n        var hasControlledValue = false;\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\n        if (isFormElement) {\n            hasControlledValue = processElement_1.isControlledFormElement(props);\n        }\n        for (var prop in props) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patching_1.patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\n        }\n        if (isFormElement) {\n            processElement_1.processElement(flags, vNode, dom, props, true, hasControlledValue);\n        }\n    }\n    if (inferno_shared_1.isNullOrUndef(className)) {\n        dom.removeAttribute('class');\n    }\n    else {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (ref) {\n        mounting_1.mountRef(dom, ref, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\n    normalizeChildNodes(parentDom);\n    var dom = parentDom.firstChild;\n    if (inferno_shared_1.isArray(children)) {\n        for (var i = 0, len = children.length; i < len; i++) {\n            var child = children[i];\n            if (!inferno_shared_1.isNull(child) && inferno_shared_1.isObject(child)) {\n                if (!inferno_shared_1.isNull(dom)) {\n                    dom = hydrate(child, dom, lifecycle, context, isSVG).nextSibling;\n                }\n                else {\n                    mounting_1.mount(child, parentDom, lifecycle, context, isSVG);\n                }\n            }\n        }\n    }\n    else if (inferno_shared_1.isStringOrNumber(children)) {\n        if (dom && dom.nodeType === 3) {\n            if (dom.nodeValue !== children) {\n                dom.nodeValue = children;\n            }\n        }\n        else if (children) {\n            parentDom.textContent = children;\n        }\n        dom = dom.nextSibling;\n    }\n    else if (inferno_shared_1.isObject(children)) {\n        hydrate(children, dom, lifecycle, context, isSVG);\n        dom = dom.nextSibling;\n    }\n    // clear any other DOM nodes, there should be only a single entry for the root\n    while (dom) {\n        var nextSibling = dom.nextSibling;\n        parentDom.removeChild(dom);\n        dom = nextSibling;\n    }\n}\nfunction hydrateText(vNode, dom) {\n    if (dom.nodeType !== 3) {\n        var newDom = mounting_1.mountText(vNode, null);\n        vNode.dom = newDom;\n        utils_1.replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    var text = vNode.children;\n    if (dom.nodeValue !== text) {\n        dom.nodeValue = text;\n    }\n    vNode.dom = dom;\n    return dom;\n}\nfunction hydrateVoid(vNode, dom) {\n    vNode.dom = dom;\n    return dom;\n}\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        return hydrateComponent(vNode, dom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 3970 /* Element */) {\n        return hydrateElement(vNode, dom, lifecycle, context, isSVG);\n    }\n    else if (flags & 1 /* Text */) {\n        return hydrateText(vNode, dom);\n    }\n    else if (flags & 4096 /* Void */) {\n        return hydrateVoid(vNode, dom);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError(\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + typeof vNode + \"\\\".\");\n        }\n        inferno_shared_1.throwError();\n    }\n}\nfunction hydrateRoot(input, parentDom, lifecycle) {\n    if (!inferno_shared_1.isNull(parentDom)) {\n        var dom = parentDom.firstChild;\n        if (!inferno_shared_1.isNull(dom)) {\n            hydrate(input, dom, lifecycle, utils_1.EMPTY_OBJ, false);\n            dom = parentDom.firstChild;\n            // clear any other DOM nodes, there should be only a single entry for the root\n            while (dom = dom.nextSibling) {\n                parentDom.removeChild(dom);\n            }\n            return true;\n        }\n    }\n    return false;\n}\nexports.hydrateRoot = hydrateRoot;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/wrappers/processElement.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar InputWrapper_1 = require(\"./InputWrapper\");\nvar SelectWrapper_1 = require(\"./SelectWrapper\");\nvar TextareaWrapper_1 = require(\"./TextareaWrapper\");\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 512 /* InputElement */) {\n        InputWrapper_1.processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\n    }\n    if (flags & 2048 /* SelectElement */) {\n        SelectWrapper_1.processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\n    }\n    if (flags & 1024 /* TextareaElement */) {\n        TextareaWrapper_1.processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\n    }\n}\nexports.processElement = processElement;\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return (nextPropsOrEmpty.type && InputWrapper_1.isCheckedType(nextPropsOrEmpty.type)) ? !inferno_shared_1.isNullOrUndef(nextPropsOrEmpty.checked) : !inferno_shared_1.isNullOrUndef(nextPropsOrEmpty.value);\n}\nexports.isControlledFormElement = isControlledFormElement;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/wrappers/InputWrapper.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar utils_1 = require(\"../utils\");\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nexports.isCheckedType = isCheckedType;\nfunction onTextInputChange(e) {\n    var vNode = this;\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    var dom = vNode.dom;\n    var previousValue = props.value;\n    if (props.onInput) {\n        var event_1 = props.onInput;\n        if (event_1.event) {\n            event_1.event(event_1.data, e);\n        }\n        else {\n            event_1(e);\n        }\n    }\n    else if (props.oninput) {\n        props.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events syncronously\n    // so we need to get it from the context of `this` again\n    var newVNode = this;\n    var newProps = newVNode.props || utils_1.EMPTY_OBJ;\n    // If render is going async there is no value change yet, it will come back to process input soon\n    if (previousValue !== newProps.value) {\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\n        applyValue(newProps, dom);\n    }\n}\nfunction wrappedOnChange(e) {\n    var props = this.props || utils_1.EMPTY_OBJ;\n    var event = props.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onCheckboxChange(e) {\n    e.stopPropagation(); // This click should not propagate its for internal use\n    var vNode = this;\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    var dom = vNode.dom;\n    var previousValue = props.value;\n    if (props.onClick) {\n        var event_2 = props.onClick;\n        if (event_2.event) {\n            event_2.event(event_2.data, e);\n        }\n        else {\n            event_2(e);\n        }\n    }\n    else if (props.onclick) {\n        props.onclick(e);\n    }\n    // the user may have updated the vNode from the above onInput events syncronously\n    // so we need to get it from the context of `this` again\n    var newVNode = this;\n    var newProps = newVNode.props || utils_1.EMPTY_OBJ;\n    // If render is going async there is no value change yet, it will come back to process input soon\n    if (previousValue !== newProps.value) {\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\n        applyValue(newProps, dom);\n    }\n}\nfunction processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    applyValue(nextPropsOrEmpty, dom);\n    if (mounting && isControlled) {\n        if (isCheckedType(nextPropsOrEmpty.type)) {\n            dom.onclick = onCheckboxChange.bind(vNode);\n            dom.onclick.wrapped = true;\n        }\n        else {\n            dom.oninput = onTextInputChange.bind(vNode);\n            dom.oninput.wrapped = true;\n        }\n        if (nextPropsOrEmpty.onChange) {\n            dom.onchange = wrappedOnChange.bind(vNode);\n            dom.onchange.wrapped = true;\n        }\n    }\n}\nexports.processInput = processInput;\nfunction applyValue(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !inferno_shared_1.isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (multiple && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!inferno_shared_1.isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!inferno_shared_1.isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.value = value;\n        }\n        else if (!inferno_shared_1.isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\nexports.applyValue = applyValue;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/wrappers/SelectWrapper.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar VNodes_1 = require(\"../../core/VNodes\");\nvar utils_1 = require(\"../utils\");\nfunction updateChildOptionGroup(vNode, value) {\n    var type = vNode.type;\n    if (type === 'optgroup') {\n        var children = vNode.children;\n        if (inferno_shared_1.isArray(children)) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                updateChildOption(children[i], value);\n            }\n        }\n        else if (VNodes_1.isVNode(children)) {\n            updateChildOption(children, value);\n        }\n    }\n    else {\n        updateChildOption(vNode, value);\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if ((inferno_shared_1.isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\n        dom.selected = true;\n    }\n    else if (!inferno_shared_1.isNullOrUndef(value) || !inferno_shared_1.isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nfunction onSelectChange(e) {\n    var vNode = this;\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    var dom = vNode.dom;\n    var previousValue = props.value;\n    if (props.onChange) {\n        var event_1 = props.onChange;\n        if (event_1.event) {\n            event_1.event(event_1.data, e);\n        }\n        else {\n            event_1(e);\n        }\n    }\n    else if (props.onchange) {\n        props.onchange(e);\n    }\n    // the user may have updated the vNode from the above onInput events syncronously\n    // so we need to get it from the context of `this` again\n    var newVNode = this;\n    var newProps = newVNode.props || utils_1.EMPTY_OBJ;\n    // If render is going async there is no value change yet, it will come back to process input soon\n    if (previousValue !== newProps.value) {\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\n        applyValue(newVNode, dom, newProps, false);\n    }\n}\nfunction processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    applyValue(vNode, dom, nextPropsOrEmpty, mounting);\n    if (mounting && isControlled) {\n        dom.onchange = onSelectChange.bind(vNode);\n        dom.onchange.wrapped = true;\n    }\n}\nexports.processSelect = processSelect;\nfunction applyValue(vNode, dom, nextPropsOrEmpty, mounting) {\n    if (nextPropsOrEmpty.multiple !== dom.multiple) {\n        dom.multiple = nextPropsOrEmpty.multiple;\n    }\n    var children = vNode.children;\n    if (!inferno_shared_1.isInvalid(children)) {\n        var value = nextPropsOrEmpty.value;\n        if (mounting && inferno_shared_1.isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        if (inferno_shared_1.isArray(children)) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                updateChildOptionGroup(children[i], value);\n            }\n        }\n        else if (VNodes_1.isVNode(children)) {\n            updateChildOptionGroup(children, value);\n        }\n    }\n}\nexports.applyValue = applyValue;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/wrappers/TextareaWrapper.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar utils_1 = require(\"../utils\");\nfunction wrappedOnChange(e) {\n    var props = this.props || utils_1.EMPTY_OBJ;\n    var event = props.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onTextareaInputChange(e) {\n    var vNode = this;\n    var props = vNode.props || utils_1.EMPTY_OBJ;\n    var previousValue = props.value;\n    if (props.onInput) {\n        var event_1 = props.onInput;\n        if (event_1.event) {\n            event_1.event(event_1.data, e);\n        }\n        else {\n            event_1(e);\n        }\n    }\n    else if (props.oninput) {\n        props.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events syncronously\n    // so we need to get it from the context of `this` again\n    var newVNode = this;\n    var newProps = newVNode.props || utils_1.EMPTY_OBJ;\n    // If render is going async there is no value change yet, it will come back to process input soon\n    if (previousValue !== newProps.value) {\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\n        applyValue(newVNode, vNode.dom, false);\n    }\n}\nfunction processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    applyValue(nextPropsOrEmpty, dom, mounting);\n    if (mounting && isControlled) {\n        dom.oninput = onTextareaInputChange.bind(vNode);\n        dom.oninput.wrapped = true;\n        if (nextPropsOrEmpty.onChange) {\n            dom.onchange = wrappedOnChange.bind(vNode);\n            dom.onchange.wrapped = true;\n        }\n    }\n}\nexports.processTextarea = processTextarea;\nfunction applyValue(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (inferno_shared_1.isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!inferno_shared_1.isNullOrUndef(defaultValue)) {\n                if (defaultValue !== domValue) {\n                    dom.value = defaultValue;\n                }\n            }\n            else if (domValue !== '') {\n                dom.value = '';\n            }\n        }\n    }\n    else {\n        /* There is value so keep it controlled */\n        if (domValue !== value) {\n            dom.value = value;\n        }\n    }\n}\nexports.applyValue = applyValue;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/unmounting.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar options_1 = require(\"../core/options\");\nvar patching_1 = require(\"./patching\");\nvar recycling_1 = require(\"./recycling\");\nvar rendering_1 = require(\"./rendering\");\nvar utils_1 = require(\"./utils\");\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & 3970 /* Element */) {\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\n        unmountVoidOrText(vNode, parentDom);\n    }\n}\nexports.unmount = unmount;\nfunction unmountVoidOrText(vNode, parentDom) {\n    if (!inferno_shared_1.isNull(parentDom)) {\n        utils_1.removeChild(parentDom, vNode.dom);\n    }\n}\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var instance = vNode.children;\n    var flags = vNode.flags;\n    var isStatefulComponent = flags & 4 /* ComponentClass */;\n    var ref = vNode.ref;\n    var dom = vNode.dom;\n    if (!isRecycling) {\n        if (isStatefulComponent) {\n            if (!instance._unmounted) {\n                instance._blockSetState = true;\n                if (!inferno_shared_1.isNull(options_1.options.beforeUnmount)) {\n                    options_1.options.beforeUnmount(vNode);\n                }\n                if (!inferno_shared_1.isUndefined(instance.componentWillUnmount)) {\n                    instance.componentWillUnmount();\n                }\n                if (ref && !isRecycling) {\n                    ref(null);\n                }\n                instance._unmounted = true;\n                if (options_1.options.findDOMNodeEnabled) {\n                    rendering_1.componentToDOMNodeMap.delete(instance);\n                }\n                unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);\n            }\n        }\n        else {\n            if (!inferno_shared_1.isNullOrUndef(ref)) {\n                if (!inferno_shared_1.isNullOrUndef(ref.onComponentWillUnmount)) {\n                    ref.onComponentWillUnmount(dom);\n                }\n            }\n            unmount(instance, null, lifecycle, false, isRecycling);\n        }\n    }\n    if (parentDom) {\n        var lastInput = instance._lastInput;\n        if (inferno_shared_1.isNullOrUndef(lastInput)) {\n            lastInput = instance;\n        }\n        utils_1.removeChild(parentDom, dom);\n    }\n    if (options_1.options.recyclingEnabled && !isStatefulComponent && (parentDom || canRecycle)) {\n        recycling_1.poolComponent(vNode);\n    }\n}\nexports.unmountComponent = unmountComponent;\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var dom = vNode.dom;\n    var ref = vNode.ref;\n    var props = vNode.props;\n    if (ref && !isRecycling) {\n        unmountRef(ref);\n    }\n    var children = vNode.children;\n    if (!inferno_shared_1.isNullOrUndef(children)) {\n        unmountChildren(children, lifecycle, isRecycling);\n    }\n    if (!inferno_shared_1.isNull(props)) {\n        for (var name_1 in props) {\n            // do not add a hasOwnProperty check here, it affects performance\n            if (props[name_1] !== null && patching_1.isAttrAnEvent(name_1)) {\n                patching_1.patchEvent(name_1, props[name_1], null, dom);\n                // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling\n                props[name_1] = null;\n            }\n        }\n    }\n    if (!inferno_shared_1.isNull(parentDom)) {\n        utils_1.removeChild(parentDom, dom);\n    }\n    if (options_1.options.recyclingEnabled && (parentDom || canRecycle)) {\n        recycling_1.poolElement(vNode);\n    }\n}\nexports.unmountElement = unmountElement;\nfunction unmountChildren(children, lifecycle, isRecycling) {\n    if (inferno_shared_1.isArray(children)) {\n        for (var i = 0, len = children.length; i < len; i++) {\n            var child = children[i];\n            if (!inferno_shared_1.isInvalid(child) && inferno_shared_1.isObject(child)) {\n                unmount(child, null, lifecycle, false, isRecycling);\n            }\n        }\n    }\n    else if (inferno_shared_1.isObject(children)) {\n        unmount(children, null, lifecycle, false, isRecycling);\n    }\n}\nfunction unmountRef(ref) {\n    if (inferno_shared_1.isFunction(ref)) {\n        ref(null);\n    }\n    else {\n        if (inferno_shared_1.isInvalid(ref)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            inferno_shared_1.throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        inferno_shared_1.throwError();\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/recycling.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar inferno_shared_1 = require(\"inferno-shared\");\nvar patching_1 = require(\"./patching\");\nvar componentPools = new Map();\nvar elementPools = new Map();\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\n    var tag = vNode.type;\n    var pools = elementPools.get(tag);\n    if (!inferno_shared_1.isUndefined(pools)) {\n        var key = vNode.key;\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!inferno_shared_1.isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!inferno_shared_1.isUndefined(recycledVNode)) {\n                patching_1.patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\n                return vNode.dom;\n            }\n        }\n    }\n    return null;\n}\nexports.recycleElement = recycleElement;\nfunction poolElement(vNode) {\n    var tag = vNode.type;\n    var key = vNode.key;\n    var pools = elementPools.get(tag);\n    if (inferno_shared_1.isUndefined(pools)) {\n        pools = {\n            keyed: new Map(),\n            nonKeyed: []\n        };\n        elementPools.set(tag, pools);\n    }\n    if (inferno_shared_1.isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (inferno_shared_1.isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\nexports.poolElement = poolElement;\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\n    var type = vNode.type;\n    var pools = componentPools.get(type);\n    if (!inferno_shared_1.isUndefined(pools)) {\n        var key = vNode.key;\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!inferno_shared_1.isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!inferno_shared_1.isUndefined(recycledVNode)) {\n                var flags = vNode.flags;\n                var failed = patching_1.patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, flags & 4 /* ComponentClass */, true);\n                if (!failed) {\n                    return vNode.dom;\n                }\n            }\n        }\n    }\n    return null;\n}\nexports.recycleComponent = recycleComponent;\nfunction poolComponent(vNode) {\n    var hooks = vNode.ref;\n    var nonRecycleHooks = hooks && (hooks.onComponentWillMount ||\n        hooks.onComponentWillUnmount ||\n        hooks.onComponentDidMount ||\n        hooks.onComponentWillUpdate ||\n        hooks.onComponentDidUpdate);\n    if (nonRecycleHooks) {\n        return;\n    }\n    var type = vNode.type;\n    var key = vNode.key;\n    var pools = componentPools.get(type);\n    if (inferno_shared_1.isUndefined(pools)) {\n        pools = {\n            keyed: new Map(),\n            nonKeyed: []\n        };\n        componentPools.set(type, pools);\n    }\n    if (inferno_shared_1.isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (inferno_shared_1.isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\nexports.poolComponent = poolComponent;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/dist/DOM/events/linkEvent.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    return { data: data, event: event };\n}\nexports.linkEvent = linkEvent;\n","/home/travis/build/npmtest/node-npmtest-inferno/node_modules/inferno/__benchmarks__/createvnode.js":"import { createTextVNode, createVNode } from '../dist-es/core/VNodes';\nimport { render } from '../dist-es/index';\n\nsuite('createVNode', () => {\n\t/* Do not compare results between each other, these only measure OPS / sec for different structures */\n\n\tbenchmark('Single node nulls', () => {\n\t\tcreateVNode(2, 'div', null, null);\n\t});\n\n\tbenchmark('Single node not defined', () => {\n\t\tcreateVNode(2, 'div');\n\t});\n\n\tbenchmark('Regular shape', () => {\n\t\tcreateVNode(2, 'div', null, [\n\t\t\tcreateVNode(2, 'div', null, '1'),\n\t\t\tcreateVNode(2, 'div', null, [\n\t\t\t\tcreateVNode(2, 'div', null, 'a'),\n\t\t\t\tcreateVNode(2, 'div', null, 'b'),\n\t\t\t\tcreateVNode(2, 'div', null, 'c')\n\t\t\t])\n\t\t]);\n\t});\n\n\tbenchmark('20 children siblings', () => {\n\t\tcreateVNode(2, 'div', null, [\n\t\t\tcreateVNode(2, 'div', null, '1'),\n\t\t\tcreateVNode(2, 'div', null, '2'),\n\t\t\tcreateVNode(2, 'div', null, '3'),\n\t\t\tcreateVNode(2, 'div', null, '4'),\n\t\t\tcreateVNode(2, 'div', null, '5'),\n\t\t\tcreateVNode(2, 'div', null, '6'),\n\t\t\tcreateVNode(2, 'div', null, '7'),\n\t\t\tcreateVNode(2, 'div', null, '8'),\n\t\t\tcreateVNode(2, 'div', null, '9'),\n\t\t\tcreateVNode(2, 'div', null, '10'),\n\t\t\tcreateVNode(2, 'div', null, '11'),\n\t\t\tcreateVNode(2, 'div', null, '12'),\n\t\t\tcreateVNode(2, 'div', null, '13'),\n\t\t\tcreateVNode(2, 'div', null, '14'),\n\t\t\tcreateVNode(2, 'div', null, '15'),\n\t\t\tcreateVNode(2, 'div', null, '16'),\n\t\t\tcreateVNode(2, 'div', null, '17'),\n\t\t\tcreateVNode(2, 'div', null, '18'),\n\t\t\tcreateVNode(2, 'div', null, '19'),\n\t\t\tcreateVNode(2, 'div', null, '20')\n\t\t]);\n\t});\n\n\tbenchmark('33 nested nodes', () => {\n\t\tcreateVNode(2, 'div', null, (\n\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreateVNode(2, 'div', null, 'child33')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));\n\t});\n\n\tbenchmark('Table shape', () => {\n\t\tcreateVNode(2, 'table', null, [\n\t\t\tcreateVNode(2, 'thead', null, createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(2, 'th', null, 'h1')\n\t\t\t\t, createVNode(2, 'th', null, 'h2')\n\t\t\t\t, createVNode(2, 'th', null, 'h3')\n\t\t\t\t, createVNode(2, 'th', null, 'h4')\n\t\t\t]))\n\t\t\t, createVNode(2, 'tbody', null, [ createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(\n\t\t\t\t\t2, 'td', null, '1')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '2')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '3')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '4')\n\t\t\t]), createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(\n\t\t\t\t\t2, 'td', null, '5')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '6')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '7')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '8')\n\t\t\t]), createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(\n\t\t\t\t\t2, 'td', null, '9')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '10')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '11')\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, '12')\n\t\t\t]) ])\n\t\t]);\n\t});\n\n\tbenchmark('text node childs (table shape)', () => {\n\t\tcreateVNode(2, 'table', null, [\n\t\t\tcreateVNode(2, 'thead', null, createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(2, 'th', null, createTextVNode('h1'))\n\t\t\t\t, createVNode(2, 'th', null, createTextVNode('h2'))\n\t\t\t\t, createVNode(2, 'th', null, createTextVNode('h3'))\n\t\t\t\t, createVNode(2, 'th', null, createTextVNode('h4'))\n\t\t\t]))\n\t\t\t, createVNode(2, 'tbody', null, [ createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('1'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('2'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('3'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('4'))\n\t\t\t]), createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('5'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('6'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('7'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('8'))\n\t\t\t]), createVNode(2, 'tr', null, [\n\t\t\t\tcreateVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('9'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('10'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('11'))\n\t\t\t\t, createVNode(\n\t\t\t\t\t2, 'td', null, createTextVNode('12'))\n\t\t\t]) ])\n\t\t]);\n\t});\n\n\tbenchmark('navigation shape ul - li', () => {\n\t\tcreateVNode(2, 'nav', null, createVNode(2, 'ul', null, [ createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'Home')), createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'About')), createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'Clients')), createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'Contact Us')) ]));\n\t});\n\n\tbenchmark('typical html page', () => {\n\t\tcreateVNode(2, 'html', null, [ createVNode(2, 'head'), createVNode(2, 'body', null, createVNode(2, 'div', {\n\t\t\tclass: 'flex-container'\n\t\t}, [ createVNode(2, 'header', null, createVNode(2, 'h1', null, 'City Gallery')), createVNode(2, 'nav', {\n\t\t\tclass: 'nav'\n\t\t}, createVNode(2, 'ul', null, [ createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'London')), createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'Paris')), createVNode(2, 'li', null, createVNode(2, 'a', {\n\t\t\thref: '#'\n\t\t}, 'Tokyo')) ])), createVNode(2, 'article', {\n\t\t\tclass: 'article'\n\t\t}, [ createVNode(2, 'h1', null, 'London'), createVNode(2, 'p', null, 'London'), createVNode(2, 'p', null, createVNode(2, 'strong', null, 'Resize')) ]), createVNode(2, 'footer', null, 'Copyright \\xA9 W3Schools.com') ])) ]);\n\t});\n\n\tbenchmark('deeply nested Arrays (nobody should do this)', () => {\n\t\tcreateVNode(2, 'div', null, [\n\t\t\tcreateVNode(2, 'div', null, '1'),\n\t\t\tcreateVNode(2, 'div', null, [ [ [ [ [ [\n\t\t\t\t[ [ createVNode(2, 'div', null, 'a') ] ],\n\t\t\t\t[ [ [ [ [ createVNode(2, 'div', null, 'b') ] ] ] ] ],\n\t\t\t\t[ [ [ [ [ createVNode(2, 'div', null, 'c') ] ] ] ] ]\n\t\t\t] ] ] ] ] ])\n\t\t]);\n\t});\n\n\tbenchmark('Changing attributes (includes render)', () => {\n\t\tvar container = document.createElement('div');\n\t\t// Mount\n\t\trender(createVNode(2, 'div', {\n\t\t\tclassName: 'foo bar',\n\t\t\tstyle: {\n\t\t\t\tcolor: 'red',\n\t\t\t\tfloat: 'left'\n\t\t\t},\n\t\t\t'data-attribute': 'data-value',\n\t\t\t'custom-stuff': 'custom',\n\t\t}), container);\n\n\t\t// Change\n\t\trender(createVNode(2, 'div', {\n\t\t\tclassName: 'bar',\n\t\t\tstyle: {\n\t\t\t\tcolor: 'blue'\n\t\t\t},\n\t\t\t'data-attribute': 'data-value'\n\t\t}), container);\n\n\t\t// Remove all\n\t\trender(createVNode(2, 'div', null), container);\n\t});\n});\n"}